<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BS Card Game</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
<style>
body {
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
    display: flex; flex-direction: column; align-items: center;
    background: #0f6f2f; height: 100vh;
}
header { padding:10px; background:#073b15; color:white; width:100%; text-align:center;}
#game-container { margin-top:10px; }
button { margin:5px; font-size:16px; }
</style>
</head>
<body>
<header>
<h1>BS Game</h1>
</header>

<button id="doneTurn">Done Turn</button>
<button id="callBS">Call BS!</button>
<div id="game-container"></div>

<script>
const config = {
    type: Phaser.AUTO,
    width: 1000,
    height: 600,
    backgroundColor: 0x228B22,
    parent: 'game-container',
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let playerHands = [[], []];
let currentPlayer = 0;
let selectedCards = [];
let pile = [];
let expectedRankIndex = 0; // 0 = Ace, 1 = 2, ..., 12 = King
const suits = ["Hearts","Diamonds","Clubs","Spades"];
const values = ["ace","2","3","4","5","6","7","8","9","10","jack","queen","king"];
let handContainerY = [450, 50]; // bottom/top player hands
let handScrollOffset = [0,0];

function preload() {
    // load card images
    suits.forEach(suit => {
        values.forEach(value => {
            this.load.image(`${value}_${suit}`, `assets/cards/${value}_of_${suit}.png`);
        });
    });
    this.load.image('back', 'assets/cards/back.png');
}

function create() {
    // create deck
    let deck = [];
    suits.forEach(suit => values.forEach(value => deck.push({suit, value})));
    Phaser.Utils.Array.Shuffle(deck);

    // deal all cards evenly
    for (let i=0;i<deck.length;i++) {
        playerHands[i%2].push(deck[i]);
    }

    // input for card selection
    this.input.on('pointerdown', (pointer, gameObject) => {});

    drawHands(this);

    // drag selection (optional)
    this.input.on('dragstart', (pointer, card) => {
        if(card.playerIndex !== currentPlayer) return;
        card.setScale(1.1);
        if(!selectedCards.includes(card)) selectedCards.push(card);
    });
    this.input.on('drag', (pointer, card, dragX, dragY)=> { card.x=dragX; card.y=dragY; });
    this.input.on('dragend', (pointer, card)=> { card.setScale(1); });

    document.getElementById('doneTurn').addEventListener('click', ()=> playTurn(this));
    document.getElementById('callBS').addEventListener('click', ()=> callBS(this));
}

function drawHands(scene) {
    // remove old cards
    if(scene.handGroup) scene.handGroup.clear(true,true);
    scene.handGroup = scene.add.group();

    for(let p=0;p<2;p++) {
        let hand = playerHands[p];
        let startX = 100;
        let spacing = 80;
        let y = handContainerY[p];
        let offsetX = handScrollOffset[p];

        hand.forEach((card,i)=>{
            let sprite = scene.add.image(startX + i*spacing - offsetX, y, `${card.value}_${card.suit}`).setInteractive();
            sprite.setDisplaySize(60,90);
            sprite.playerIndex = p;
            scene.input.setDraggable(sprite);
            scene.handGroup.add(sprite);
        });
    }

    drawPile(scene);
    drawExpectedRank(scene);
}

function drawPile(scene) {
    if(scene.pileGroup) scene.pileGroup.clear(true,true);
    scene.pileGroup = scene.add.group();
    let x = 500, y = 280;
    pile.forEach((card,i)=>{
        let sprite = scene.add.image(x + (i%5)*5, y + Math.floor(i/5)*5, 'back'); // back for pile
        sprite.setDisplaySize(60,90);
        scene.pileGroup.add(sprite);
    });
}

function drawExpectedRank(scene){
    if(scene.rankText) scene.rankText.destroy();
    scene.rankText = scene.add.text(850, 280, `Expected: ${values[expectedRankIndex]}`, {font:'24px Arial', fill:'#fff'});
}

function playTurn(scene){
    if(selectedCards.length===0) { alert("Select cards to play"); return; }

    // validate correct player
    for(let c of selectedCards){
        if(c.playerIndex !== currentPlayer){
            alert("You can only play your own cards");
            selectedCards=[];
            drawHands(scene);
            return;
        }
    }

    // remove from hand
    selectedCards.forEach(c=>{
        playerHands[currentPlayer] = playerHands[currentPlayer].filter(card=> !(card.value + card.suit === c.texture.key.replace('_','')));
        pile.push({value: values[expectedRankIndex], cards: [c.texture.key]}); // store actual cards but face down
    });

    selectedCards = [];
    expectedRankIndex = (expectedRankIndex+1)%13;
    currentPlayer = (currentPlayer+1)%2;

    drawHands(scene);
}

function callBS(scene){
    if(pile.length===0) { alert("No cards to challenge!"); return; }

    let lastPlay = pile[pile.length-1];
    let lastPlayer = (currentPlayer+1)%2; // previous player

    // check if any card does not match expected rank
    let lie = lastPlay.cards.some(c => !c.startsWith(values[(expectedRankIndex-1+13)%13]));

    if(lie){
        alert(`BS! Player ${lastPlayer+1} lied. They pick up the pile.`);
        playerHands[lastPlayer] = playerHands[lastPlayer].concat(pile.map(p=>p.cards).flat());
    }else{
        alert(`BS! Player ${lastPlayer+1} told the truth. You pick up the pile.`);
        playerHands[currentPlayer] = playerHands[currentPlayer].concat(pile.map(p=>p.cards).flat());
    }

    pile=[];
    drawHands(scene);
}

function update(){}
</script>
</body>
</html>
